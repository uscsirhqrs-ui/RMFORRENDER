/**
 * @fileoverview Export Utility Functions
 * Handles export to CSV (using PapaParse) and PDF (using jsPDF).
 */

import Papa from 'papaparse';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

/**
 * Downloads data as CSV
 * @param data Array of objects
 * @param filename File name (without extension)
 */
export const exportToCSV = (data: any[], filename: string) => {
    if (!data || data.length === 0) {
        console.warn("No data to export");
        return;
    }

    // Flatten data slightly for better CSV output (optional, depends on structure)
    // For now, we assume data is reasonably flat or relying on string representation
    const csv = Papa.unparse(data);
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');

    if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `${filename}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
};

/**
 * Downloads data as PDF table
 * @param data Array of objects
 * @param columns Array of column definitions { header: string, dataKey: string }
 * @param title PDF Title
 * @param filename File name (without extension)
 */
export const exportToPDF = (
    data: any[],
    columns: { header: string; dataKey: string }[],
    title: string,
    filename: string,
    exportedBy?: string,
    filterSummary?: string,
    orientation: 'portrait' | 'landscape' = 'landscape'
) => {
    if (!data || data.length === 0) {
        console.warn("No data to export");
        return;
    }

    const doc = new jsPDF({ orientation });

    // Title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.text(title, 14, 20);

    // Metadata
    doc.setFontSize(10);

    // Generated on
    doc.setTextColor(79, 70, 229); // Indigo
    doc.setFont("helvetica", "regular");
    const genLabel = "Generated on: ";
    doc.text(genLabel, 14, 28);

    const genLabelWidth = doc.getTextWidth(genLabel);
    doc.setTextColor(0, 0, 0);
    doc.setFont("helvetica", "regular");
    doc.text(new Date().toLocaleString(), 14 + genLabelWidth, 28);

    let currentY = 34;

    if (exportedBy) {
        doc.setTextColor(79, 70, 229); // Indigo
        doc.setFont("helvetica", "regular");
        const expLabel = "Generated by: ";
        doc.text(expLabel, 14, currentY);

        const expLabelWidth = doc.getTextWidth(expLabel);
        doc.setTextColor(0, 0, 0);
        doc.setFont("helvetica", "regular");
        doc.text(exportedBy, 14 + expLabelWidth, currentY);
        currentY += 6;
    }

    // Always show Filters line
    doc.setTextColor(79, 70, 229); // Indigo
    doc.setFont("helvetica", "regular");
    const filterLabel = "Filters: ";
    doc.text(filterLabel, 14, currentY);

    const filterLabelWidth = doc.getTextWidth(filterLabel);
    doc.setTextColor(0, 0, 0);
    doc.setFont("helvetica", "regular");

    const summaryText = filterSummary || "-NIL-";

    const maxTextWidth = 180 - filterLabelWidth;
    const splitText = doc.splitTextToSize(summaryText, maxTextWidth);
    doc.text(splitText, 14 + filterLabelWidth, currentY);
    currentY += (splitText.length * 5) + 2;

    // Prepare table body based on columns
    const tableBody = data.map(row => {
        const rowData: any = {};
        columns.forEach(col => {
            // Handle nested properties if dataKey has dots (e.g. "markedToDetails.fullName")
            const keys = col.dataKey.split('.');
            let val = row;
            for (const key of keys) {
                if (val && typeof val === 'object') {
                    val = val[key];
                } else {
                    val = '';
                    break;
                }
            }
            rowData[col.dataKey] = val || '';
        });
        return rowData;
    });

    const tableColumns = columns.map(c => ({ header: c.header, dataKey: c.dataKey }));

    autoTable(doc, {
        head: [tableColumns.map(c => c.header)],
        body: tableBody.map(row => tableColumns.map(c => row[c.dataKey])),
        startY: currentY, // Dynamic spacing
        styles: { fontSize: 8, cellPadding: 2 },
        headStyles: { fillColor: [79, 70, 229] }, // Indigo-600 logic
    });

    doc.save(`${filename}.pdf`);
};
